#pragma once
#include <eosio/testing/tester.hpp>

namespace eosio { namespace testing {

struct contracts {
   static std::vector<uint8_t> token_wasm() { return read_wasm("${CMAKE_BINARY_DIR}/../contracts/token/token.wasm"); }
   static std::vector<char>    token_abi() { return read_abi("${CMAKE_BINARY_DIR}/../contracts/token/token.abi"); }
   static std::vector<uint8_t> system_wasm() { return read_wasm("${CMAKE_BINARY_DIR}/../contracts/system/system.wasm"); }
   static std::vector<char>    system_abi() { return read_abi("${CMAKE_BINARY_DIR}/../contracts/system/system.abi"); }
   static std::vector<uint8_t> htlc_wasm() { return read_wasm("${CMAKE_BINARY_DIR}/../contracts/htlc/htlc.wasm"); }
   static std::vector<char>    htlc_abi() { return read_abi("${CMAKE_BINARY_DIR}/../contracts/htlc/htlc.abi"); }
   static std::vector<uint8_t> account_wasm() { return read_wasm("${CMAKE_BINARY_DIR}/../contracts/account/account.wasm"); }
   static std::vector<char>    account_abi() { return read_abi("${CMAKE_BINARY_DIR}/../contracts/account/account.abi"); }
   static std::vector<uint8_t> reserve_wasm() { return read_wasm("${CMAKE_BINARY_DIR}/../contracts/reserve/reserve.wasm"); }
   static std::vector<char>    reserve_abi() { return read_abi("${CMAKE_BINARY_DIR}/../contracts/reserve/reserve.abi"); }
   static std::vector<uint8_t> gacha_wasm() { return read_wasm("${CMAKE_BINARY_DIR}/../contracts/gacha/gacha.wasm"); }
   static std::vector<char>    gacha_abi() { return read_abi("${CMAKE_BINARY_DIR}/../contracts/gacha/gacha.abi"); }

};

}} /// namespace eosio::testing
